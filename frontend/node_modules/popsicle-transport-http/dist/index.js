"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transport = exports.AbortError = exports.NegotiateHttpVersion = exports.ALPNError = exports.ConnectionError = exports.Http2ConnectionManager = exports.SocketConnectionManager = exports.SocketSet = exports.Http2Response = exports.HttpResponse = void 0;
const url_1 = require("url");
const http_1 = require("http");
const https_1 = require("https");
const make_error_cause_1 = require("make-error-cause");
const net_1 = require("net");
const tls_1 = require("tls");
const http2_1 = require("http2");
const stream_1 = require("stream");
const dns_1 = require("dns");
const node_1 = require("servie/dist/node");
const common_1 = require("servie/dist/common");
/**
 * HTTP responses implement a node.js body.
 */
class HttpResponse extends node_1.Response {
    constructor(body, options) {
        super(body, options);
        this.url = options.url;
        this.connection = options.connection;
        this.httpVersion = options.httpVersion;
    }
}
exports.HttpResponse = HttpResponse;
class Http2Response extends HttpResponse {
}
exports.Http2Response = Http2Response;
/**
 * Set of connections for HTTP pooling.
 */
class SocketSet {
    constructor() {
        // Tracks number of sockets claimed before they're created.
        this.creating = 0;
        // Tracks free sockets.
        this.free = new Set();
        // Tracks all available sockets.
        this.sockets = new Set();
        // Tracks pending requests for a socket.
        this.pending = [];
    }
}
exports.SocketSet = SocketSet;
/**
 * Manage socket reuse.
 */
class SocketConnectionManager {
    constructor(maxFreeConnections = 256, maxConnections = Infinity) {
        this.maxFreeConnections = maxFreeConnections;
        this.maxConnections = maxConnections;
        this.pools = new Map();
    }
    /**
     * Creates a connection when available.
     */
    ready(key, onReady) {
        const pool = this.pool(key);
        // Wrap `onReady` in a temporary socket claim when socket is `null`.
        const callback = (socket) => {
            if (socket)
                return onReady(socket);
            pool.creating++;
            return onReady(null).finally(() => pool.creating--);
        };
        // Add to "pending" queue when over max connections.
        if (pool.creating + pool.sockets.size >= this.maxConnections) {
            return new Promise((resolve) => pool.pending.push(resolve)).then(callback);
        }
        const socket = pool.free.values().next().value;
        if (socket)
            pool.free.delete(socket);
        return callback(socket);
    }
    pool(key) {
        if (!this.pools.has(key))
            this.pools.set(key, new SocketSet());
        return this.pools.get(key);
    }
    claim(key, socket) {
        socket.ref();
        const pool = this.pool(key);
        pool.sockets.add(socket);
    }
    release(key, socket) {
        socket.unref();
        const pool = this.pool(key);
        // Immediately reuse for pending connection.
        if (pool.pending.length) {
            const onReady = pool.pending.shift();
            onReady(socket);
            return false;
        }
        // Save freed connections for reuse.
        if (pool.free.size < this.maxFreeConnections) {
            pool.free.add(socket);
            return false;
        }
        this.delete(key, socket);
        return true;
    }
    get(key) {
        const pool = this.pools.get(key);
        if (pool)
            return pool.sockets.values().next().value;
    }
    free(key) {
        const pool = this.pools.get(key);
        if (pool)
            return pool.free.values().next().value;
    }
    delete(key, socket) {
        const pool = this.pools.get(key);
        if (!pool || !pool.sockets.has(socket))
            return;
        // Delete all references to the socket.
        pool.free.delete(socket);
        pool.sockets.delete(socket);
        // Create a new pending socket when an old socket is removed.
        // If a socket was removed we MUST be below `maxConnections`.
        // We also MUST have already used our `free` connections up otherwise we
        // wouldn't have a pending callback.
        const onReady = pool.pending.shift();
        if (onReady) {
            onReady(null); // No socket to reuse here.
            return;
        }
        // Remove pool when there are no sockets to track anymore.
        if (!pool.creating && !pool.sockets.size)
            this.pools.delete(key);
    }
}
exports.SocketConnectionManager = SocketConnectionManager;
class Http2ConnectionManager {
    constructor() {
        this.sessions = new Map();
        this.refs = new WeakMap();
    }
    async ready(key, onReady) {
        const existingClient = this.sessions.get(key);
        return onReady(existingClient || null);
    }
    claim(key, session) {
        const count = this.refs.get(session) || 0;
        if (count === 0)
            session.ref();
        this.refs.set(session, count + 1);
        this.sessions.set(key, session);
    }
    release(key, session) {
        const count = this.refs.get(session) || 0;
        if (count === 1)
            session.unref();
        this.refs.set(session, count - 1);
        // Noop. To be implemented with HTTP2 throttling.
        return false;
    }
    get(key) {
        return this.sessions.get(key);
    }
    free(key) {
        return this.sessions.get(key);
    }
    delete(key, session) {
        this.refs.delete(session);
        if (this.sessions.get(key) === session)
            this.sessions.delete(key);
    }
}
exports.Http2ConnectionManager = Http2ConnectionManager;
// Global connection caches.
const globalNetConnections = new SocketConnectionManager();
const globalTlsConnections = new SocketConnectionManager();
const globalHttp2Connections = new Http2ConnectionManager();
const defaultNetConnect = net_1.connect;
const defaultTlsConnect = tls_1.connect;
const defaultHttp2Connect = (authority, socket) => {
    return http2_1.connect(authority, { createConnection: () => socket });
};
/**
 * Write Servie body to node.js stream.
 */
function pumpBody(req, stream, onError) {
    const body = common_1.useRawBody(req);
    if (body instanceof ArrayBuffer) {
        return stream.end(new Uint8Array(body));
    }
    if (Buffer.isBuffer(body) || typeof body === "string" || body === null) {
        return stream.end(body);
    }
    return stream_1.pipeline(body, stream, (err) => {
        if (err)
            return onError(err);
    });
}
/**
 * Expose connection errors.
 */
class ConnectionError extends make_error_cause_1.BaseError {
    constructor(request, message, cause) {
        super(message, cause);
        this.request = request;
        this.code = "EUNAVAILABLE";
    }
}
exports.ConnectionError = ConnectionError;
/**
 * Execute HTTP request.
 */
function execHttp1(req, url, keepAlive, socket) {
    return new Promise((resolve, reject) => {
        const encrypted = url.protocol === "https:";
        const request = encrypted ? https_1.request : http_1.request;
        const arg = {
            protocol: url.protocol,
            hostname: url.hostname,
            port: url.port,
            defaultPort: encrypted ? 443 : 80,
            method: req.method,
            path: url.pathname + url.search,
            headers: req.headers.asObject(),
            auth: url.username || url.password
                ? `${url.username}:${url.password}`
                : undefined,
            createConnection: () => socket,
        };
        const rawRequest = request(arg);
        // Handle abort events correctly.
        const onAbort = () => {
            req.signal.off("abort", onAbort);
            socket.emit("agentRemove"); // `abort` destroys the connection with no event.
            rawRequest.destroy();
        };
        // Reuse HTTP connections where possible.
        if (keepAlive > 0) {
            rawRequest.shouldKeepAlive = true;
            rawRequest.setHeader("Connection", "keep-alive");
        }
        // Trigger unavailable error when node.js errors before response.
        const onRequestError = (err) => {
            req.signal.off("abort", onAbort);
            rawRequest.removeListener("response", onResponse);
            return reject(new ConnectionError(req, `Unable to connect to ${url.host}`, err));
        };
        // Track the node.js response.
        const onResponse = (rawResponse) => {
            // Trailers are populated on "end".
            let resolveTrailers;
            const trailer = new Promise((resolve) => (resolveTrailers = resolve));
            rawRequest.removeListener("response", onResponse);
            rawRequest.removeListener("error", onRequestError);
            const { address: localAddress, port: localPort, } = rawRequest.connection.address();
            const { address: remoteAddress, port: remotePort, } = rawResponse.connection.address();
            const responseStream = new stream_1.PassThrough();
            let bytesTransferred = 0;
            const onData = (chunk) => {
                req.signal.emit("responseBytes", (bytesTransferred += chunk.length));
            };
            // Force `end` to be triggered so the response can still be piped.
            // Reference: https://github.com/nodejs/node/issues/27981
            const onAborted = () => {
                rawResponse.push(null);
                responseStream.end();
            };
            rawResponse.on("data", onData);
            rawResponse.on("aborted", onAborted);
            req.signal.emit("responseStarted");
            const res = new HttpResponse(stream_1.pipeline(rawResponse, responseStream, (err) => {
                req.signal.off("abort", onAbort);
                rawResponse.removeListener("data", onData);
                rawResponse.removeListener("aborted", onAborted);
                resolveTrailers(rawResponse.trailers);
                if (err)
                    req.signal.emit("error", err);
                req.signal.emit("responseEnded");
            }), {
                status: rawResponse.statusCode,
                statusText: rawResponse.statusMessage,
                url: req.url,
                headers: rawResponse.headers,
                omitDefaultHeaders: true,
                trailer,
                connection: {
                    localAddress,
                    localPort,
                    remoteAddress,
                    remotePort,
                    encrypted,
                },
                httpVersion: rawResponse.httpVersion,
            });
            return resolve(res);
        };
        let bytesTransferred = 0;
        const onData = (chunk) => {
            req.signal.emit("requestBytes", (bytesTransferred += chunk.length));
        };
        const requestStream = new stream_1.PassThrough();
        req.signal.on("abort", onAbort);
        rawRequest.once("error", onRequestError);
        rawRequest.once("response", onResponse);
        requestStream.on("data", onData);
        req.signal.emit("requestStarted");
        stream_1.pipeline(requestStream, rawRequest, () => {
            requestStream.removeListener("data", onData);
            req.signal.emit("requestEnded");
        });
        return pumpBody(req, requestStream, reject);
    });
}
/**
 * ALPN validation error.
 */
class ALPNError extends Error {
    constructor(request, message) {
        super(message);
        this.request = request;
        this.code = "EALPNPROTOCOL";
    }
}
exports.ALPNError = ALPNError;
/**
 * Execute a HTTP2 connection.
 */
function execHttp2(req, url, client) {
    return new Promise((resolve, reject) => {
        // HTTP2 formatted headers.
        const headers = Object.assign({
            [http2_1.constants.HTTP2_HEADER_METHOD]: req.method,
            [http2_1.constants.HTTP2_HEADER_AUTHORITY]: url.host,
            [http2_1.constants.HTTP2_HEADER_SCHEME]: url.protocol.slice(0, -1),
            [http2_1.constants.HTTP2_HEADER_PATH]: url.pathname + url.search,
        }, req.headers.asObject());
        const http2Stream = client.request(headers, { endStream: false });
        // Trigger unavailable error when node.js errors before response.
        const onRequestError = (err) => {
            req.signal.off("abort", onAbort);
            http2Stream.removeListener("response", onResponse);
            return reject(new ConnectionError(req, `Unable to connect to ${url.host}`, err));
        };
        const onResponse = (headers) => {
            const encrypted = client.socket.encrypted === true;
            const { localAddress, localPort, remoteAddress = "", remotePort = 0, } = client.socket;
            let resolveTrailers;
            const trailer = new Promise((resolve) => (resolveTrailers = resolve));
            http2Stream.removeListener("error", onRequestError);
            http2Stream.removeListener("response", onResponse);
            const onTrailers = (headers) => {
                resolveTrailers(headers);
            };
            let bytesTransferred = 0;
            const onData = (chunk) => {
                req.signal.emit("responseBytes", (bytesTransferred += chunk.length));
            };
            http2Stream.on("data", onData);
            http2Stream.once("trailers", onTrailers);
            req.signal.emit("responseStarted");
            const res = new Http2Response(stream_1.pipeline(http2Stream, new stream_1.PassThrough(), (err) => {
                req.signal.off("abort", onAbort);
                http2Stream.removeListener("data", onData);
                http2Stream.removeListener("data", onTrailers);
                resolveTrailers({}); // Resolve in case "trailers" wasn't emitted.
                if (err)
                    req.signal.emit("error", err);
                req.signal.emit("responseEnded");
            }), {
                status: Number(headers[http2_1.constants.HTTP2_HEADER_STATUS]),
                statusText: "",
                url: req.url,
                httpVersion: "2.0",
                headers,
                omitDefaultHeaders: true,
                trailer,
                connection: {
                    localAddress,
                    localPort,
                    remoteAddress,
                    remotePort,
                    encrypted,
                },
            });
            return resolve(res);
        };
        const onAbort = () => http2Stream.destroy();
        let bytesTransferred = 0;
        const onData = (chunk) => {
            req.signal.emit("requestBytes", (bytesTransferred += chunk.length));
        };
        const requestStream = new stream_1.PassThrough();
        req.signal.on("abort", onAbort);
        http2Stream.once("error", onRequestError);
        http2Stream.once("response", onResponse);
        requestStream.on("data", onData);
        req.signal.emit("requestStarted");
        stream_1.pipeline(requestStream, http2Stream, () => {
            requestStream.removeListener("data", onData);
            req.signal.emit("requestEnded");
        });
        return pumpBody(req, requestStream, reject);
    });
}
/**
 * Wrap `execHttp2` with support for a connection manager instance.
 */
function manageHttp2(manager, key, client, req, url) {
    manager.claim(key, client);
    return execHttp2(req, url, client).finally(() => manager.release(key, client));
}
/**
 * Configure HTTP version negotiation.
 */
var NegotiateHttpVersion;
(function (NegotiateHttpVersion) {
    NegotiateHttpVersion[NegotiateHttpVersion["HTTP1_ONLY"] = 0] = "HTTP1_ONLY";
    NegotiateHttpVersion[NegotiateHttpVersion["HTTP2_FOR_HTTPS"] = 1] = "HTTP2_FOR_HTTPS";
    NegotiateHttpVersion[NegotiateHttpVersion["HTTP2_ONLY"] = 2] = "HTTP2_ONLY";
})(NegotiateHttpVersion = exports.NegotiateHttpVersion || (exports.NegotiateHttpVersion = {}));
/**
 * Custom abort error instance.
 */
class AbortError extends Error {
    constructor(request, message) {
        super(message);
        this.request = request;
        this.code = "EABORT";
    }
}
exports.AbortError = AbortError;
/**
 * Forward request over HTTP1/1 or HTTP2, with TLS support.
 */
function transport(options = {}) {
    const { keepAlive = 5000, // Default to keeping a connection open briefly.
    negotiateHttpVersion = NegotiateHttpVersion.HTTP2_FOR_HTTPS, lookup = dns_1.lookup, tlsSockets = globalTlsConnections, netSockets = globalNetConnections, http2Sessions = globalHttp2Connections, createNetConnection = defaultNetConnect, createTlsConnection = defaultTlsConnect, createHttp2Connection = defaultHttp2Connect, } = options;
    return async function (req, next) {
        const url = new url_1.URL(req.url, "http://localhost");
        const { hostname, protocol } = url;
        if (req.signal.aborted) {
            throw new AbortError(req, "Request has been aborted");
        }
        if (protocol === "http:") {
            const port = Number(url.port) || 80;
            const connectionKey = `${hostname}:${port}:${negotiateHttpVersion}`;
            if (negotiateHttpVersion === NegotiateHttpVersion.HTTP2_ONLY) {
                const existingClient = http2Sessions.free(connectionKey);
                if (existingClient) {
                    return manageHttp2(http2Sessions, connectionKey, existingClient, req, url);
                }
            }
            const socket = await netSockets.ready(connectionKey, async (existingSocket) => {
                if (existingSocket)
                    return existingSocket;
                const socket = await createNetConnection({
                    host: hostname,
                    port,
                    lookup,
                });
                setupSocket(netSockets, connectionKey, socket, keepAlive);
                return socket;
            });
            // Claim net socket for usage after `ready`.
            netSockets.claim(connectionKey, socket);
            // Use existing HTTP2 session in HTTP2-only mode.
            if (negotiateHttpVersion === NegotiateHttpVersion.HTTP2_ONLY) {
                const client = await http2Sessions.ready(connectionKey, async (existingClient) => {
                    if (existingClient)
                        return existingClient;
                    const client = await createHttp2Connection(url, socket);
                    setupHttp2Client(http2Sessions, connectionKey, client, keepAlive);
                    return client;
                });
                return manageHttp2(http2Sessions, connectionKey, client, req, url);
            }
            return execHttp1(req, url, keepAlive, socket);
        }
        // Optionally negotiate HTTP2 connection.
        if (protocol === "https:") {
            const { ca, cert, key, secureProtocol, secureContext, secureOptions, } = options;
            const port = Number(url.port) || 443;
            const servername = options.servername ||
                calculateServerName(hostname, req.headers.get("host"));
            const rejectUnauthorized = options.rejectUnauthorized !== false;
            const connectionKey = `${hostname}:${port}:${negotiateHttpVersion}:${servername}:${rejectUnauthorized}:${ca || ""}:${cert || ""}:${key || ""}:${secureProtocol || ""}`;
            // Use an existing HTTP2 session before making a new attempt.
            if (negotiateHttpVersion === NegotiateHttpVersion.HTTP2_ONLY ||
                negotiateHttpVersion === NegotiateHttpVersion.HTTP2_FOR_HTTPS) {
                const existingSession = http2Sessions.free(connectionKey);
                if (existingSession) {
                    return manageHttp2(http2Sessions, connectionKey, existingSession, req, url);
                }
            }
            // Use an existing TLS session to speed up handshake.
            const existingSocket = tlsSockets.get(connectionKey);
            const session = existingSocket ? existingSocket.getSession() : undefined;
            const ALPNProtocols = negotiateHttpVersion === NegotiateHttpVersion.HTTP2_ONLY
                ? ["h2"]
                : negotiateHttpVersion === NegotiateHttpVersion.HTTP2_FOR_HTTPS
                    ? ["h2", "http/1.1"]
                    : undefined;
            const socketOptions = {
                host: hostname,
                port,
                servername,
                rejectUnauthorized,
                ca,
                cert,
                key,
                session,
                secureProtocol,
                secureContext,
                ALPNProtocols,
                lookup,
                secureOptions,
            };
            const socket = await tlsSockets.ready(connectionKey, async (existingSocket) => {
                if (existingSocket)
                    return existingSocket;
                const socket = await createTlsConnection(socketOptions);
                setupSocket(tlsSockets, connectionKey, socket, keepAlive);
                return socket;
            });
            // Claim TLS socket after `ready`.
            tlsSockets.claim(connectionKey, socket);
            if (negotiateHttpVersion === NegotiateHttpVersion.HTTP1_ONLY) {
                return execHttp1(req, url, keepAlive, socket);
            }
            if (negotiateHttpVersion === NegotiateHttpVersion.HTTP2_ONLY) {
                const client = await http2Sessions.ready(connectionKey, async (existingClient) => {
                    if (existingClient)
                        return existingClient;
                    const client = await createHttp2Connection(url, socket);
                    setupHttp2Client(http2Sessions, connectionKey, client, keepAlive);
                    return client;
                });
                return manageHttp2(http2Sessions, connectionKey, client, req, url);
            }
            return new Promise((resolve, reject) => {
                const onClose = () => {
                    socket.removeListener("error", onError);
                    socket.removeListener("connect", onConnect);
                    return reject(new ALPNError(req, "TLS connection closed early"));
                };
                const onError = (err) => {
                    socket.removeListener("connect", onConnect);
                    socket.removeListener("close", onClose);
                    return reject(new ConnectionError(req, `Unable to connect to ${hostname}:${port}`, err));
                };
                // Execute HTTP connection according to negotiated ALPN protocol.
                const onConnect = () => {
                    socket.removeListener("error", onError);
                    socket.removeListener("close", onClose);
                    // Workaround for https://github.com/nodejs/node/pull/32958/files#r418695485.
                    socket.secureConnecting = false;
                    // Successfully negotiated HTTP2 connection.
                    if (socket.alpnProtocol === "h2") {
                        return resolve(http2Sessions
                            .ready(connectionKey, async (existingClient) => {
                            if (existingClient) {
                                tlsSockets.release(connectionKey, socket);
                                return existingClient;
                            }
                            const client = await createHttp2Connection(url, socket);
                            setupHttp2Client(http2Sessions, connectionKey, client, keepAlive);
                            return client;
                        })
                            .then((client) => {
                            return manageHttp2(http2Sessions, connectionKey, client, req, url);
                        }));
                    }
                    if (socket.alpnProtocol === "http/1.1" || !socket.alpnProtocol) {
                        return resolve(execHttp1(req, url, keepAlive, socket));
                    }
                    return reject(new ALPNError(req, `Unknown ALPN protocol negotiated: ${socket.alpnProtocol}`));
                };
                // Existing socket may already have negotiated ALPN protocol.
                if (socket.alpnProtocol != null)
                    return onConnect();
                socket.once("secureConnect", onConnect);
                socket.once("error", onError);
                socket.once("close", onClose);
            });
        }
        return next();
    };
}
exports.transport = transport;
/**
 * Setup the socket with the connection manager.
 *
 * Ref: https://github.com/nodejs/node/blob/531b4bedcac14044f09129ffb65dab71cc2707d9/lib/_http_agent.js#L254
 */
function setupSocket(manager, key, socket, keepAlive) {
    const onFree = () => {
        if (keepAlive > 0)
            socket.setKeepAlive(true, keepAlive);
        const destroy = manager.release(key, socket);
        if (destroy)
            socket.destroy();
    };
    const cleanup = () => {
        socket.removeListener("free", onFree);
        socket.removeListener("close", cleanup);
        socket.removeListener("agentRemove", cleanup);
        manager.delete(key, socket);
    };
    socket.on("free", onFree);
    socket.on("close", cleanup);
    socket.on("agentRemove", cleanup);
}
/**
 * Set up a HTTP2 working session.
 */
function setupHttp2Client(manager, key, client, keepAlive) {
    client.once("error", () => manager.delete(key, client));
    client.once("goaway", () => manager.delete(key, client));
    client.once("close", () => manager.delete(key, client));
    client.setTimeout(keepAlive, () => client.close());
}
/**
 * Ref: https://github.com/nodejs/node/blob/5823938d156f4eb6dc718746afbf58f1150f70fb/lib/_http_agent.js#L231
 */
function calculateServerName(hostname, hostHeader) {
    if (!hostHeader)
        return hostname;
    if (hostHeader.charAt(0) === "[") {
        const index = hostHeader.indexOf("]");
        if (index === -1)
            return hostHeader;
        return hostHeader.substr(1, index - 1);
    }
    return hostHeader.split(":", 1)[0];
}
//# sourceMappingURL=index.js.map